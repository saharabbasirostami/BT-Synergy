# -*- coding: utf-8 -*-
"""data_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RXswWkwvGfkkEZqB3AHPISbKxhP_9szw
"""

import numpy as np
import pandas as pd

# =========================================================
# Data Loading Functions
# =========================================================

def get_list_of_proteins(path_dataset, dataset):

    data_dp = pd.read_csv(f"{path_dataset}{dataset}/drug_protein.csv")
    proteins_from_drugs = data_dp.iloc[:, 1].unique()

    data_cp = pd.read_csv(f"{path_dataset}{dataset}/cell_protein.csv")
    proteins_from_cells = data_cp.iloc[:, 2].unique()

    list_of_prots = np.unique(np.concatenate([proteins_from_drugs, proteins_from_cells]))
    return list_of_prots

def get_list_of_drugs(path_dataset, dataset):
    data_dp = pd.read_csv(f"{path_dataset}{dataset}/drug_protein.csv")
    list_of_drugs = np.unique(data_dp.iloc[:,0].unique())

    data_comb = pd.read_csv(f"{path_dataset}{dataset}/drug_combinations.csv")
    list_of_drugs = np.unique(np.concatenate([list_of_drugs, data_comb.iloc[:,3].unique(), data_comb.iloc[:,4].unique()]))

    return list_of_drugs

def get_list_of_cells(path_dataset, dataset):
    data_cp = pd.read_csv(f"{path_dataset}{dataset}/cell_protein.csv")
    list_of_cells = data_cp.iloc[:,3].unique()

    data_comb = pd.read_csv(f"{path_dataset}{dataset}/drug_combinations.csv")
    list_of_cells = np.unique(np.concatenate([list_of_cells, data_comb.iloc[:,2].unique()]))

    return list_of_cells

def read_protein_drug_matrix(path_dataset, dataset, list_of_prots, list_of_drugs):
    data = pd.read_csv(f"{path_dataset}{dataset}/drug_protein.csv")
    matrix = np.zeros((len(list_of_prots), len(list_of_drugs)))
    for i in range(data.shape[0]):
        prot_idx = np.argwhere(list_of_prots == data.iloc[i,1])[0][0]
        drug_idx = np.argwhere(list_of_drugs == data.iloc[i,0])[0][0]
        matrix[prot_idx, drug_idx] = 1
    return matrix

def read_protein_cell_matrix(path_dataset, dataset, list_of_prots, list_of_cells):
    data = pd.read_csv(f"{path_dataset}{dataset}/cell_protein.csv")
    matrix = np.zeros((len(list_of_prots), len(list_of_cells)))
    for i in range(data.shape[0]):
        prot_idx = np.argwhere(list_of_prots == data.iloc[i,2])[0][0]
        cell_idx = np.argwhere(list_of_cells == data.iloc[i,3])[0][0]
        matrix[prot_idx, cell_idx] = 1
    return matrix

def read_drug_combinations_data(path_dataset, dataset, list_of_drugs, list_of_cells):
   """
    Load drug combination data and generate binary labels for synergy.

    To handle class imbalance in synergy scores, we use the first (Q1) and third (Q3) quartiles:
    - Label 1 (synergistic) for combinations with synergy >= Q3
    - Label 0 (non-synergistic) for combinations with synergy <= Q1
    - Combinations between Q1 and Q3 are discarded

    This ensures a clearer separation between synergistic and non-synergistic pairs.

    Returns:
        labels: np.array of binary synergy labels
        indx_d1: np.array of indices for drug 1
        indx_d2: np.array of indices for drug 2
        indx_cells: np.array of indices for cell lines
    """
    data = pd.read_csv(f"{path_dataset}{dataset}/drug_combinations.csv")
    synergy_values = np.array(data.iloc[:,5])
    q1, q3 = np.percentile(synergy_values, [25,75])

    indx_d1, indx_d2, indx_cells, labels = [], [], [], []

    for i in range(data.shape[0]):
        synergy = data.iloc[i,5]
        if synergy >= q3:
            label = 1
        elif synergy <= q1:
            label = 0
        else:
            continue
        d1 = np.argwhere(list_of_drugs == data.iloc[i,3])[0][0]
        d2 = np.argwhere(list_of_drugs == data.iloc[i,4])[0][0]
        c  = np.argwhere(list_of_cells == data.iloc[i,2])[0][0]
        indx_d1.append(d1)
        indx_d2.append(d2)
        indx_cells.append(c)
        labels.append([label])

    return np.array(labels), np.array(indx_d1), np.array(indx_d2), np.array(indx_cells)